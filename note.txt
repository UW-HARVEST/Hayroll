HAYROLL: HARVEST Annotator for Yielding Regions of Lexed Logic

awk 'NR==144 {print substr($0, 32, 15)}' /home/husky/libmcs/libm/include/internal_config.h

awk 'NR==144 {print substr($0, 1, 31) "ESCAPED" substr($0, 32)} NR!=144' /home/hurrypeng/libmcs/libm/include/internal_config.h > /tmp/hayroll.tmp && mv /tmp/hayroll.tmp /home/hurrypeng/libmcs/libm/include/internal_config.h

awk 'NR==1 {print substr($0, 1, 10) "ESCAPED" substr($0, 11)} NR!=1' ./trace.txt > /tmp/hayroll.tmp && mv /tmp/hayroll.tmp ./trace.txt

./seeder /home/hurrypeng/libmcs/macro_invocation_analyses/all_results.cpp2c ../libmcs/libm/mathf/ &> trace.txt

    {
        *"{}";
        GET_FLOAT_WORD
        (
            (
                (
                    (*"{}")?
                    (0):
                    ((__typeof__(jx)*)(0))
                )
            ),
            (
                *(
                    (*"{}")?
                    (&(x)):
                    ((__typeof__(x)*)(0))
                )
            )
        );
        *"{}";
    };

syntax = { git = "https://github.com/rust-lang/rust-analyzer" , tag = "2024-12-09" }

RUST_BACKTRACE=1 ./ws ~/libmcs-partial &> trace.txt

The current SourceChangeBuilder-based way of modifying AST has its limitations. 
It fails when two indels are overlapping (usually seen on nested AST indels). 
But if we first apply part of the editions, then the other part (represented by AST nodes)
would be invalidated and thus needs another round of analysis to refresh. 
This is not feasible, especially for more complex transformations we may do in the future. 
There is also a TreeMutator-based way for editing. We should explore that. 

TreeMutator always finds the root
clone_for_update clones the whole ancestor path

extract var
replace extra var usages (assert unifiable)
extract fn
elim extracted var on caller side
unify fn (?)

pub fn assists(
pub fn assists_with_fixes(
pub(crate) fn handle_code_action(

write a wrapper for handler: &fn(&mut Assists, &AssistContext<'_>) -> Option<()>

arch:
locator: (AST) -> ([Node])
editor: ([Node], Option<Sema>) -> 

macro_rules! GET_FLOAT_WORD {
    ($i:expr, $d:expr) => {
        *(b"{\"astKind\":\"Stmt\",\"begin\":true,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
        as *const u8 as *const libc::c_char);
        loop {
            let mut gf_u = ieee_float_shape_type { value: 0. };
            gf_u
                .value = $d;
            $i = gf_u.word as int32_t;
            if !(0 as libc::c_int == 1 as libc::c_int) {
                break;
            }
        }
        *(b"{\"astKind\":\"\",\"begin\":false,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
            as *const u8 as *const libc::c_char);
    }
}

unsafe fn GET_FLOAT_WORD(mut i: i32, d: f32) {
    *(b"{\"astKind\":\"Stmt\",\"begin\":true,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
        as *const u8 as *const libc::c_char);
    loop {
        let mut gf_u = ieee_float_shape_type { value: 0. };
        gf_u
            .value = d;
        i = gf_u.word as int32_t;
        if !(0 as libc::c_int == 1 as libc::c_int) {
            break;
        }
    }
    *(b"{\"astKind\":\"\",\"begin\":false,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
        as *const u8 as *const libc::c_char);
}

fn add<T>(a: T, b: T) -> T {
    a + b
}

fn addAddable<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

func:
    return type:
        lvalue: *if{}else{0 as *mut T} -> *mut T
        rvalue: if{}else{*(0 as *mut T)} -> T
    return mut: lvalue->&mut(/* cannot return reference to temporary value */)/own, rvalue->own(val)
    ban: unbounded new var decl, !IsHygienic, DoesBodyReferenceDeclDeclaredAfterMacro (?)
    call site:
        lvalue: *if{}else{} -> *(NAME(*mut (lvalue_spelling), rvalue_spelling))
        rvalue: if{}else{} -> NAME(*mut (lvalue_spelling), rvalue_spelling)
arg:
    type:
        lvalue: *if{}else{0 as *mut T} -> *mut T
        rvalue: if{}else{*(0 as *mut T)} -> T
    mut: lvalue->(&mut x, *x = ..., ... = *x), rvalue->own(val)
    ban: side effect, !expr
    use:
        lvalue: *if{}else{} -> *name
        rvalue: if{}else{} -> name

own -> own
&mut -> &mut

t = *&mut s
    requires typeof(s) to implement Copy trait
    is actually copying the value of t and storing into s

let mut hrs: HayrollSeed = HayrollSeed {
    ...
};
hrs = (*&mut HayrollSeed { // The star here can be omitted due to coercion, but the parentheses must be written out
    literal: ast::Literal::cast(element.parent()?)?,
    tag: tag.clone(),
    file_id: file_id.clone(),
}).clone();

/usr/bin/c++ -H -I/home/hurrypeng/Hayroll/include -I/home/hurrypeng/Hayroll/../tree-sitter/lib/include -I/home/hurrypeng/Hayroll/../tree-sitter-c_preproc/bindings/c -isystem /usr/lib/llvm-14/include -std=c++20 -MD -MT CMakeFiles/pioneer.dir/src/pioneer.cpp.o -MF CMakeFiles/pioneer.dir/src/pioneer.cpp.o.d -o CMakeFiles/pioneer.dir/src/pioneer.cpp.o -c /home/hurrypeng/Hayroll/src/pioneer.cpp
/usr/bin/clang -H -I/home/hurrypeng/Hayroll/include -I/home/hurrypeng/Hayroll/../tree-sitter/lib/include -I/home/hurrypeng/Hayroll/../tree-sitter-c_preproc/bindings/c -isystem /usr/lib/llvm-14/include -std=c++20 -MD -MT CMakeFiles/pioneer.dir/src/pioneer.cpp.o -MF CMakeFiles/pioneer.dir/src/pioneer.cpp.o.d -o CMakeFiles/pioneer.dir/src/pioneer.cpp.o -c /home/hurrypeng/Hayroll/src/pioneer.cpp

note: clang -H does not include files that are skipped due to header guards, 
so when we see the IncludeTree missing a header, it could be that:
    (1) it's skipped due to header guard
    (2) or, it's in an #if branch that is not covered by previous runs of the clang -H (under their -Dxxx conditions)
During symbolic execution, to make sure it is (1) before deciding to skip it,
each IncludeTree should hold a condition. If (condState -> condTree),
then (2) cannot be a reason of the missing, which means it must be (1). If !(condState -> condTree),
then we must run clang -H again with condState, generate a new tree (whose cond is same as condState)
merge the tree to the existing one (whose condition is now (condTree || condNewTree)), then retry searching. 
Only if the tree still does not contain the file can we make sure it's skipped due to header guards
