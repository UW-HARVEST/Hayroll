HAYROLL: HARVEST Annotator for Yielding Regions of Lexed Logic

awk 'NR==144 {print substr($0, 32, 15)}' /home/husky/libmcs/libm/include/internal_config.h

awk 'NR==144 {print substr($0, 1, 31) "ESCAPED" substr($0, 32)} NR!=144' /home/hurrypeng/libmcs/libm/include/internal_config.h > /tmp/hayroll.tmp && mv /tmp/hayroll.tmp /home/hurrypeng/libmcs/libm/include/internal_config.h

awk 'NR==1 {print substr($0, 1, 10) "ESCAPED" substr($0, 11)} NR!=1' ./trace.txt > /tmp/hayroll.tmp && mv /tmp/hayroll.tmp ./trace.txt

./hoe /home/hurrypeng/libmcs/macro_invocation_analyses/all_results.cpp2c ../libmcs/libm/mathf/ &> trace.txt

    {
        *"{}";
        GET_FLOAT_WORD
        (
            (
                (
                    (*"{}")?
                    (0):
                    ((__typeof__(jx)*)(0))
                )
            ),
            (
                *(
                    (*"{}")?
                    (&(x)):
                    ((__typeof__(x)*)(0))
                )
            )
        );
        *"{}";
    };

syntax = { git = "https://github.com/rust-lang/rust-analyzer" , tag = "2024-12-09" }

./ws ~/libmcs-partial &> trace.txt

The current SourceChangeBuilder-based way of modifying AST has its limitations. 
It fails when two indels are overlapping (usually seen on nested AST indels). 
But if we first apply part of the editions, then the other part (represented by AST nodes)
would be invalidated and thus needs another round of analysis to refresh. 
This is not feasible, especially for more complex transformations we may do in the future. 
There is also a TreeMutator-based way for editing. We should explore that. 

TreeMutator always finds the root
clone_for_update clones the whole ancestor path
