HAYROLL: HARVEST Annotator for Yielding Regions of Lexed Logic

awk 'NR==144 {print substr($0, 32, 15)}' /home/husky/libmcs/libm/include/internal_config.h

awk 'NR==144 {print substr($0, 1, 31) "ESCAPED" substr($0, 32)} NR!=144' /home/hurrypeng/libmcs/libm/include/internal_config.h > /tmp/hayroll.tmp && mv /tmp/hayroll.tmp /home/hurrypeng/libmcs/libm/include/internal_config.h

awk 'NR==1 {print substr($0, 1, 10) "ESCAPED" substr($0, 11)} NR!=1' ./trace.txt > /tmp/hayroll.tmp && mv /tmp/hayroll.tmp ./trace.txt

./seeder /home/hurrypeng/libmcs/macro_invocation_analyses/all_results.cpp2c ../libmcs/libm/mathf/ &> trace.txt

    {
        *"{}";
        GET_FLOAT_WORD
        (
            (
                (
                    (*"{}")?
                    (0):
                    ((__typeof__(jx)*)(0))
                )
            ),
            (
                *(
                    (*"{}")?
                    (&(x)):
                    ((__typeof__(x)*)(0))
                )
            )
        );
        *"{}";
    };

syntax = { git = "https://github.com/rust-lang/rust-analyzer" , tag = "2024-12-09" }

RUST_BACKTRACE=1 ./ws ~/libmcs-partial &> trace.txt

The current SourceChangeBuilder-based way of modifying AST has its limitations. 
It fails when two indels are overlapping (usually seen on nested AST indels). 
But if we first apply part of the editions, then the other part (represented by AST nodes)
would be invalidated and thus needs another round of analysis to refresh. 
This is not feasible, especially for more complex transformations we may do in the future. 
There is also a TreeMutator-based way for editing. We should explore that. 

TreeMutator always finds the root
clone_for_update clones the whole ancestor path

extract var
replace extra var usages (assert unifiable)
extract fn
elim extracted var on caller side
unify fn (?)

pub fn assists(
pub fn assists_with_fixes(
pub(crate) fn handle_code_action(

write a wrapper for handler: &fn(&mut Assists, &AssistContext<'_>) -> Option<()>

arch:
locator: (AST) -> ([Node])
editor: ([Node], Option<Sema>) -> 

macro_rules! GET_FLOAT_WORD {
    ($i:expr, $d:expr) => {
        *(b"{\"astKind\":\"Stmt\",\"begin\":true,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
        as *const u8 as *const libc::c_char);
        loop {
            let mut gf_u = ieee_float_shape_type { value: 0. };
            gf_u
                .value = $d;
            $i = gf_u.word as int32_t;
            if !(0 as libc::c_int == 1 as libc::c_int) {
                break;
            }
        }
        *(b"{\"astKind\":\"\",\"begin\":false,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
            as *const u8 as *const libc::c_char);
    }
}

unsafe fn GET_FLOAT_WORD(mut i: i32, d: f32) {
    *(b"{\"astKind\":\"Stmt\",\"begin\":true,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
        as *const u8 as *const libc::c_char);
    loop {
        let mut gf_u = ieee_float_shape_type { value: 0. };
        gf_u
            .value = d;
        i = gf_u.word as int32_t;
        if !(0 as libc::c_int == 1 as libc::c_int) {
            break;
        }
    }
    *(b"{\"astKind\":\"\",\"begin\":false,\"hayroll\":true,\"isArg\":false,\"isLvalue\":false,\"locDecl\":\"/home/hurrypeng/libmcs/libm/common/tools.h:327:9\",\"locInv\":\"\",\"name\":\"GET_FLOAT_WORD\"}\0"
        as *const u8 as *const libc::c_char);
}

fn add<T>(a: T, b: T) -> T {
    a + b
}

fn addAddable<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

func:
    return type:
        lvalue: *if{}else{0 as *mut T} -> *mut T
        rvalue: if{}else{*(0 as *mut T)} -> T
    return mut: lvalue->&mut(/* cannot return reference to temporary value */)/own, rvalue->own(val)
    ban: unbounded new var decl, !IsHygienic, DoesBodyReferenceDeclDeclaredAfterMacro (?)
    call site:
        lvalue: *if{}else{} -> *(NAME(&mut (lvalue_spelling), rvalue_spelling))
        rvalue: if{}else{} -> NAME(&mut (lvalue_spelling), rvalue_spelling)
arg:
    type:
        lvalue: *if{}else{0 as *mut T} -> *mut T
        rvalue: if{}else{*(0 as *mut T)} -> T
    mut: lvalue->(&mut x, *x = ..., ... = *x), rvalue->own(val)
    ban: side effect, !expr
    use:
        lvalue: *if{}else{} -> *name
        rvalue: if{}else{} -> name

own -> own
&mut -> &mut

t = *&mut s
    requires typeof(s) to implement Copy trait
    is actually copying the value of t and storing into s

let mut hrs: HayrollSeed = HayrollSeed {
    ...
};
hrs = (*&mut HayrollSeed { // The star here can be omitted due to coercion, but the parentheses must be written out
    literal: ast::Literal::cast(element.parent()?)?,
    tag: tag.clone(),
    file_id: file_id.clone(),
}).clone();
