++++
<img src="images/hayroll-200x200.png" align="right" width="200px"/>
++++

== The HARVEST Hayroll C macro to Rust translator

Hayroll converts C macros into Rust code. Hayroll wraps the
https://github.com/immunant/c2rust[c2rust] tool for converting code
written in C to the Rust programming language, improving c2rust’s
translation of C preprocessor macros and conditional compilation. The
`hayroll` command is a drop-in replacement for c2rust. "`Hayroll`"
stands for "`**H**ARVEST **A**nnotator for **Y**ielding **R**egions
**O**f **L**exical **L**ogic`".

=== Example

The `c2rust` program runs the C preprocessor before translating from C
to Rust. This means that macros are expanded (which destroys
abstractions that the programmer put in the code) and that
conditionally-compiled code is lost.

For example, consider translating this C code:

<b>This is bold.</b>

+++<code><pre>Here is text
more text
always <b>more</b> text.</pre></code>+++

+++
<pre><code>
float sinhf(float x) {
#ifdef __LIBMCS_FPU_DAZ
    x *= __volatile_onef;
#endif /* defined(__LIBMCS_FPU_DAZ) */
    +_float_+ t, w, h;
    int32_t ix, jx;
    <font color="brown">GET_FLOAT_WORD(jx, x);</font>
    ix = jx & 0x7fffffff;
    /* x is INF or NaN */
    if (!<font color="blue">FLT_UWORD_IS_FINITE(ix)</font>) {
        return x + x;
    }
    h = 0.5f;
    ...
</code></pre>
+++


[source,c,subs="+macros"]
----
+++<b>This has to be interpreted as HTML</b>+++
<span>This has not to be interpreted as HTML but as TEXT</span>
float sinhf(float x) {
[.red]++#ifdef __LIBMCS_FPU_DAZ++
    x *= __volatile_onef;
#endif /* defined(__LIBMCS_FPU_DAZ) */++
    +_float_+ t, w, h;
    int32_t ix, jx;
    <font color="brown">GET_FLOAT_WORD(jx, x);</font>
    ix = jx & 0x7fffffff;
    /* x is INF or NaN */
    if (!<font color="blue">FLT_UWORD_IS_FINITE(ix)</font>) {
        return x + x;
    }
pass:[<del>strike this</del>]
+++<del>    h = 0.5f;</del>+++
    ...
----


=== Installation

To install Hayroll:

....
git clone https://github.com/UW-HARVEST/Hayroll
cd Hayroll
./prerequisites.bash
./build.bash
# Optionally, run tests (takes less than one minute):
cd ./build && ctest
....

The `prerequisites.bash` script has been tested on Ubuntu. For
installation on other operating systems, follow the instructions in
prerequisites.md, and contribute back your instructions or a pull
request to make `prerequisites.bash` work on more operating systems.

=== Usage

The `./hayroll` executable offers a turn-key solution from C source
files to Rust files, with macros (partially) preserving their
structures.

....
 ./hayroll <path_to_compile_commands.json> <output_directory>
....

==== `compile++_++commands.json`

To build a project, a C build system typically makes multiple calls to the
compiler with a long list of arguments. A `compile_commands.json` records
these commands and arguments for the convenience of downstream analysis.

An easy way to generate a `compile++_++commands.json` file is to run

....
make clean && bear -- make
....

==== Skipping some C files

You should manually delete any source files that you do not want to translate.

==== Output

`./hayroll` overwrites the output directory. You will see several intermediate
files for each original C file.

* `xxx.c`: The C source file.
* `xxx.cu.c`: The C compilation unit source file. This is `xxx.c` with
all necessary `#include`s copy-pasted into a single file, which we call
the compilation unit file. A compilation unit file is standalone
compilable.
* `xxx.cpp2c`: Maki’s macro analysis result on `xxx.cu.c`.
* `xxx.seeded.cu.c`: `xxx.cu.c` with Hayroll’s macro info tags (seeds)
inserted (seeded).
* `xxx.seeded.rs`: `xxx.seeded.cu.c` translated to Rust by C2Rust, where
C macros were expanded and translated as-is, together with Hayroll’s
seeds.
* `xxx.rs`: The final output, Rust code with previously expanded C macro
sections reverted into Rust functions or Rust macros.

==== Example

This section shows how to run Hayroll on version 1.2.0 of the
https://gitlab.com/gtd-gmbh/libmcs[LibmCS mathematical library].

===== Clone and configure LibmCS

....
git clone --branch 1.2.0 https://gitlab.com/gtd-gmbh/libmcs.git
cd libmcs
# Passing an explicit empty string to --cross-compile prevents the script
# from prompting for a tool-chain path; all other options are disabled to
# match Hayroll’s requirements.
./configure \
    --cross-compile="" \
    --compilation-flags="" \
    --disable-denormal-handling \
    --disable-long-double-procedures \
    --disable-complex-procedures \
    --little-endian
....

===== Create `compile++_++commands.json`

....
make clean && bear -- make
....

This command creates a `compile++_++commands.json` file of this form:

....
[
  {
    "arguments": [
      "/usr/bin/gcc",
      "-c",
      "-Wall",
      "-std=c99",
      "-pedantic",
      "-Wextra",
      "-frounding-math",
      "-g",
      "-fno-builtin",
      "-DLIBMCS_FPU_DAZ",
      "-DLIBMCS_WANT_COMPLEX",
      "-Ilibm/include",
      "-Ilibm/common",
      "-Ilibm/mathd/internal",
      "-Ilibm/mathf/internal",
      "-o",
      "build-x86_64-linux-gnu/obj/libm/mathf/sinhf.o",
      "libm/mathf/sinhf.c"
    ],
    "directory": "/home/<username>/libmcs",
    "file": "/home/<username>/libmcs/libm/mathf/sinhf.c",
    "output": "/home/<username>/libmcs/build-x86_64-linux-gnu/obj/libm/mathf/sinhf.o"
  },
  ...
]
....

===== Remove some files

LibmCS uses complex numbers, but c2rust does not have full support for
complex numbers. Therefore, delete the source files under
`libm/complexf/`:

....
rm -rf libm/complexf/
....

===== Run Hayroll

....
/PATH/TO/hayroll compile_commands.json hayroll-output/
....

In the `hayroll-output/` directory, you will find files such as
`XXX.rs`.
