// A clang-based command line tool that removes all non-macro code from a C file that does not contain comments
// leaving only the preprocessor directives
// Most part of the file is generated by LLM

#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Frontend/FrontendAction.h"
#include "clang/Frontend/CompilerInstance.h"
#include "clang/Rewrite/Core/Rewriter.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringRef.h"

using namespace clang;
using namespace clang::tooling;
using namespace llvm;

static cl::OptionCategory MyToolCategory("Remove Non-Preprocessor Tool Options");
static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);

class RemoveNonPreprocessorAction : public ASTFrontendAction {
public:
    RemoveNonPreprocessorAction() {}

    std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI, StringRef InFile) override {
        return std::make_unique<ASTConsumer>();
    }

    void EndSourceFileAction() override {
        SourceManager &SM = getCompilerInstance().getSourceManager();
        FileID MainFID = SM.getMainFileID();
        StringRef Buffer = SM.getBufferData(MainFID);
        
        SmallVector<StringRef, 32> Lines;
        Buffer.split(Lines, "\n");

        std::string Output;
        bool inPreproc = false; // Mark if the last line stops with a backslash and is a continuation of a preprocessor directive

        for (const auto &Line : Lines) {
        // Save the original line length
        size_t LineLen = Line.size();
        // trimLeft is used to determine the first non-empty character of this line
        StringRef Trimmed = Line.ltrim();

        // If the first character of the current line is '#', it is considered the beginning of a preprocessor directive
        // Or if the previous line is a preprocessor directive continuation, the current line also counts
        if ((!Trimmed.empty() && Trimmed[0] == '#') || inPreproc) {
            Output.append(Line.str());
        } else {
            // Replace each character in the entire line (except the newline character) with a space
            std::string blank(LineLen, ' ');
            Output.append(blank);
        }
        Output.push_back('\n');

        // Determine if the current line ends with a backslash (ignoring trailing whitespace)
        size_t pos = Line.find_last_not_of(" \t");
        if (pos != StringRef::npos && Line[pos] == '\\') {
            inPreproc = true;
        } else {
            inPreproc = false;
        }
        }
        llvm::outs() << Output;
    }
};

int main(int argc, const char **argv) {
    auto OptionsParser = CommonOptionsParser::create(argc, argv, MyToolCategory);
    if (!OptionsParser) {
        llvm::errs() << OptionsParser.takeError();
        return 1;
    }
    ClangTool Tool(OptionsParser->getCompilations(), OptionsParser->getSourcePathList());
    return Tool.run(newFrontendActionFactory<RemoveNonPreprocessorAction>().get());
}