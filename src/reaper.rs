// Analyzes HAYROLL tags generated by seeder and extracts macro invocations into Rust macros or functions

use std::{collections::HashMap, env, ops::RangeInclusive, path::Path, time::Instant, vec};
use ide::{Edition, RootDatabase, SourceChange};
use ide_db::{base_db::{SourceDatabase, SourceDatabaseFileInputExt, SourceRootDatabase}, source_change::{SourceChangeBuilder, TreeMutator}, symbol_index::SymbolsDatabase, EditionedFileId};
use project_model::CargoConfig;
use load_cargo;
use anyhow::Result;
use serde_json::{self, value};
use syntax::{ast::{self, HasAttrs, SourceFile}, syntax_editor::Element, ted::{self, Position}, AstNode, AstToken, SyntaxElement, SyntaxNode, SyntaxToken, T};
use vfs::FileId;
use std::fs;

// Create an AST node from a string
fn ast_from_text<N: AstNode>(text: &str) -> N {
    let parse = SourceFile::parse(text, Edition::CURRENT);
    let node = match parse.tree().syntax().descendants().find_map(N::cast) {
        Some(it) => it,
        None => {
            let node = std::any::type_name::<N>();
            panic!("Failed to make ast node `{node}` from text {text}")
        }
    };
    let node = node.clone_subtree();
    assert_eq!(node.syntax().text_range().start(), 0.into());
    node
}

// Create an expression from a string
fn expr_from_text(text: &str) -> ast::Expr {
    ast_from_text(&format!("const C: () = {text};"))
}

// Get a mutable dollar token from a macro_rules
fn get_dollar_token_mut() -> SyntaxToken {
    let macro_rules = ast_from_text::<ast::MacroRules>("macro_rules! M {($x:expr) => {};}");
    // find a dollar token in the parsed macro_rules
    let dollar_token = macro_rules.syntax().descendants_with_tokens().find(|element| element.kind() == T![$]).unwrap().into_token().unwrap();
    let dollar_parent_node = dollar_token.parent().unwrap().clone_for_update();
    // find the dollar token in the dollar_parent_node that is now mutable
    let dollar_token_mut = dollar_parent_node.descendants_with_tokens().find(|element| element.kind() == T![$]).unwrap().into_token().unwrap();
    dollar_token_mut
}

fn get_empty_line_element_mut() -> SyntaxElement {
    let empty_line = ast::make::tokens::whitespace("\n");
    syntax::NodeOrToken::Token(empty_line)
}

fn top_pos(source_file: &ast::SourceFile) -> Position {
    let first_node = source_file.syntax().children()
        .find(|element| !ast::Attr::can_cast(element.kind())).unwrap().clone();
    Position::before(&first_node)
}

fn bot_pos(source_file: &ast::SourceFile) -> Position {
    let last_node = source_file.syntax().children().last().unwrap().clone();
    Position::after(&last_node)
}

// Takes a node and keeps climbing up to the parent node until the node itself is of the given kind i.e. IfExpr
// Also takes a predicate to check if the node satisfies the extra condition
fn parent_until_kind_and_cond<T>(node: &impl ast::AstNode, condition: fn(&T) -> bool) -> Option<T>
where
    T: ast::AstNode,
{
    let mut node = node.syntax().clone();
    while !(T::can_cast(node.kind()) && condition(&T::cast(node.clone()).unwrap())) {
        node = node.parent()?;
    }
    Some(T::cast(node)?)
}

// Takes a node and keeps climbing up to the parent node until the node itself is of the given kind i.e. IfExpr
fn parent_until_kind<T>(node: &impl ast::AstNode) -> Option<T>
where
    T: ast::AstNode,
{
    parent_until_kind_and_cond(node, |_| true)
}

// Takes a node and returns the parent node until the parent node satisfies the condition
#[allow(dead_code)]
fn parent_until(node: SyntaxNode, condition: fn(SyntaxNode) -> bool) -> Option<SyntaxNode> {
    let mut node = node;
    while !condition(node.clone()) {
        node = node.parent()?;
    }
    Some(node)
}

// Keep climbing up the AST from the given node until we find the source file
fn get_source_file(node: &impl ast::AstNode) -> ast::SourceFile {
    parent_until_kind::<ast::SourceFile>(node).unwrap()
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
struct LnCol {
    line: u32,
    col: u32,
}

impl LnCol {
    fn new(line: u32, col: u32) -> Self {
        LnCol { line, col }
    }

    fn from_cu_ln_col(cu_ln_col: &str) -> Self {
        let mut parts = cu_ln_col.split(':');
        let line: u32 = parts.next().unwrap().parse().unwrap();
        let col: u32 = parts.next().unwrap().parse().unwrap();
        LnCol::new(line, col)
    }
}

// Find all ast::Item in a SourceFile, who has a #[c2rust::src_loc = "9:1"] attribute
// that is within a certain range
fn find_items_in_range(source_file: &ast::SourceFile, range: std::ops::RangeInclusive<LnCol>) -> Vec<ast::Item> {
    source_file.syntax().descendants()
        .filter_map(ast::Item::cast)
        .filter(|item| {
            item.attrs().any(|attr| {
                attr.meta().map_or(false, |meta| {
                    meta.path().map_or(false, |path| path.to_string() == "c2rust::src_loc")
                    &&
                    meta.expr().map_or(false, |expr| {
                        ast::String::cast(expr.syntax().first_token().unwrap())
                            .map_or(false, |string| {
                                let cu_loc = string.value();
                                let loc = LnCol::from_cu_ln_col(&cu_loc.as_ref().unwrap());
                                range.contains(&loc)
                            })
                    })
                })
            })
        })
        .collect()
}

// HayrollTag literal in the source code
#[derive(Clone)]
struct HayrollTag {
    literal: ast::Literal,
    tag: serde_json::Value,
    file_id: FileId,
}

// Intermediate trait: any type that can expose an underlying HayrollTag
// Implementing this automatically grants a HayrollMeta implementation
// via the blanket impl below.
trait HasHayrollTag {
    fn hayroll_tag(&self) -> &HayrollTag;
}

impl HasHayrollTag for HayrollTag {
    fn hayroll_tag(&self) -> &HayrollTag { self }
}

// Trait abstraction for hayroll metadata (blanket impl provided for HasHayrollTag types)
trait HayrollMeta {
    fn is_arg(&self) -> bool;
    fn name(&self) -> String;
    fn arg_names(&self) -> Vec<String>;
    fn loc_begin(&self) -> String;
    fn loc_end(&self) -> String;
    fn cu_ln_col_begin(&self) -> String;
    fn cu_ln_col_end(&self) -> String;
    fn loc_ref_begin(&self) -> String;
    fn can_be_fn(&self) -> bool;
    fn file_id(&self) -> FileId;
    fn is_lvalue(&self) -> bool;
    fn ast_kind(&self) -> String;
    fn begin(&self) -> bool;
    fn is_expr(&self) -> bool;
    fn is_stmt(&self) -> bool;
    fn is_stmts(&self) -> bool;
    fn is_decl(&self) -> bool;
    fn is_decls(&self) -> bool;
}

impl<T: HasHayrollTag> HayrollMeta for T {
    fn is_arg(&self) -> bool { self.hayroll_tag().tag["isArg"] == true }
    fn name(&self) -> String { self.hayroll_tag().tag["name"].as_str().unwrap().to_string() }
    fn arg_names(&self) -> Vec<String> { self.hayroll_tag().tag["argNames"].as_array().unwrap().iter().map(|a| a.as_str().unwrap().to_string()).collect() }
    fn loc_begin(&self) -> String { self.hayroll_tag().tag["locBegin"].as_str().unwrap().to_string() }
    fn loc_end(&self) -> String { self.hayroll_tag().tag["locEnd"].as_str().unwrap().to_string() }
    fn cu_ln_col_begin(&self) -> String { self.hayroll_tag().tag["cuLnColBegin"].as_str().unwrap().to_string() }
    fn cu_ln_col_end(&self) -> String { self.hayroll_tag().tag["cuLnColEnd"].as_str().unwrap().to_string() }
    fn loc_ref_begin(&self) -> String { self.hayroll_tag().tag["locRefBegin"].as_str().unwrap().to_string() }
    fn can_be_fn(&self) -> bool { self.hayroll_tag().tag["canBeFn"] == true }
    fn file_id(&self) -> FileId { self.hayroll_tag().file_id }
    fn is_lvalue(&self) -> bool { self.hayroll_tag().tag["isLvalue"] == true }
    fn ast_kind(&self) -> String { self.hayroll_tag().tag["astKind"].as_str().unwrap().to_string() }
    fn begin(&self) -> bool { self.hayroll_tag().tag["begin"] == true }
    fn is_expr(&self) -> bool { self.ast_kind() == "Expr" }
    fn is_stmt(&self) -> bool { self.ast_kind() == "Stmt" }
    fn is_stmts(&self) -> bool { self.ast_kind() == "Stmts" }
    fn is_decl(&self) -> bool { self.ast_kind() == "Decl" }
    fn is_decls(&self) -> bool { self.ast_kind() == "Decls" }
}

// HayrollSeed is a tagged region in the source code
// This can be either a single expression or a span of statements
#[derive(Clone)]
enum HayrollSeed {
    Expr(HayrollTag),
    Stmts(HayrollTag, HayrollTag),
    Decls(HayrollTag),
}

impl HasHayrollTag for HayrollSeed {
    fn hayroll_tag(&self) -> &HayrollTag { self.first_tag() }
}

impl HayrollSeed {
    fn first_tag(&self) -> &HayrollTag {
        match self {
            HayrollSeed::Expr(tag) => tag,
            HayrollSeed::Stmts(tag_begin, _) => tag_begin,
            HayrollSeed::Decls(tag) => tag,
        }
    }

    // Returns immutable code region on the original AST
    // Useful for locating where to be replaced
    fn get_raw_code_region(&self, with_deref: bool) -> CodeRegion {
        match self {
            HayrollSeed::Expr(tag) => {
                let if_expr = parent_until_kind::<ast::IfExpr>(&tag.literal).unwrap();
                if with_deref && self.is_lvalue() {
                    let star_expr = parent_until_kind_and_cond::<ast::PrefixExpr>(
                        &if_expr,
                        |prefix_expr| prefix_expr.op_kind().unwrap() == ast::UnaryOp::Deref
                    ).unwrap();
                    CodeRegion::Expr(star_expr.into())
                } else {
                    CodeRegion::Expr(if_expr.into())
                }
            }
            HayrollSeed::Stmts(tag_begin, tag_end) => {
                let stmt_begin = parent_until_kind::<ast::Stmt>(&tag_begin.literal).unwrap();
                let stmt_end = parent_until_kind::<ast::Stmt>(&tag_end.literal).unwrap();
                let stmt_list = parent_until_kind::<ast::StmtList>(&stmt_begin).unwrap();
                let elements = stmt_begin..=stmt_end;
                let region = CodeRegion::Stmts { parent: stmt_list, elements };
                region
            }
            HayrollSeed::Decls(tag) => {
                // Collect all the Items in the SourceFile where the seed is
                // whose #[c2rust::src_loc = "l:c"] tags are within the cuLocBegin and cuLocEnd range in the tag
                let source_file = get_source_file(&tag.literal);
                let cu_loc_begin = LnCol::from_cu_ln_col(&self.cu_ln_col_begin());
                let cu_loc_end = LnCol::from_cu_ln_col(&self.cu_ln_col_end());
                let range = cu_loc_begin..=cu_loc_end;
                let items = find_items_in_range(&source_file, range);
                CodeRegion::Decls(items)
            }
        }
    }

    fn get_raw_decls_tag_item(&self) -> ast::Item {
        match self {
            HayrollSeed::Expr(_) => panic!("get_raw_decls_tag_item() is not applicable to Expr"),
            HayrollSeed::Stmts(_, _) => panic!("get_raw_decls_tag_item() is not applicable to Stmts"),
            HayrollSeed::Decls(seed) => {
                parent_until_kind::<ast::Item>(&seed.literal).unwrap()
            }
        }
    }

    fn lrvalue_type(&self) -> Option<ast::Type> {
        // lvalue: *if{}else{0 as *mut T} -> *mut T
        // rvalue: if{}else{*(0 as *mut T)} -> T
        match self {
            HayrollSeed::Expr(ref seed) => {
                let if_expr = parent_until_kind::<ast::IfExpr>(&seed.literal).unwrap();
                let else_branch = if_expr.else_branch().unwrap();
                let else_block = if let ast::ElseBranch::Block(block) = else_branch {
                    block
                } else {
                    panic!("Expected a block");
                };
                // Find the first ast::PtrType
                let ptr_type = else_block.syntax().descendants().find_map(
                    |element| ast::PtrType::cast(element)
                ).unwrap();
                if self.is_lvalue() {
                    Some(syntax::ast::Type::PtrType(ptr_type))
                } else {
                    Some(ptr_type.ty().unwrap())
                }
            }
            HayrollSeed::Stmts(_, _) => {
                None
            }
            HayrollSeed::Decls(_) => {
                None
            }
        }
    }

    fn base_type(&self) -> Option<ast::Type> {
        // lvalue: *if{}else{0 as *mut T} -> T
        // rvalue: if{}else{*(0 as *mut T)} -> T
        match self.lrvalue_type() {
            Some(ast::Type::PtrType(ptr_type)) if self.is_lvalue() => ptr_type.ty(),
            Some(ty) => Some(ty),
            None => None,
        }
    }

    fn is_structurally_compatible_with(&self, other: &Self) -> bool {
        match (self, other) {
            (HayrollSeed::Expr(_seed1), HayrollSeed::Expr(_seed2)) => true,
            (HayrollSeed::Stmts(_, _), HayrollSeed::Stmts(_, _)) => true,
            (HayrollSeed::Decls(_), HayrollSeed::Decls(_)) => true,
            _ => false,
        }
    }

    fn is_type_compatible_with(&self, other: &Self) -> bool {
        self.is_structurally_compatible_with(other)
        && match (self, other) {
            (HayrollSeed::Expr(_seed1), HayrollSeed::Expr(_seed2)) => {
                self.base_type() == other.base_type()
            }
            _ => true,
        }
    }
}

// A CodeRegion can be either a single expression, a span of statements,
// or a scattered set of items corresponding to C top-level declarations
#[derive(Clone)]
enum CodeRegion {
    // A single Expr
    Expr(ast::Expr),
    // A consecutive span of Stmts
    Stmts { parent: ast::StmtList, elements: RangeInclusive<ast::Stmt> },
    // A list of possibly scattered Fn/Static/Struct/Union/Const/TypeAlias/...
    Decls(Vec<ast::Item>),
}

impl CodeRegion {
    #[allow(dead_code)]
    fn clone_subtree(&self) -> CodeRegion {
        match self {
            CodeRegion::Expr(expr) => CodeRegion::Expr(expr.clone_subtree()),
            CodeRegion::Stmts { parent, elements } => {
                let begin = elements.start();
                let end = elements.end();
                // Find out the pos of the begin and end stmts
                let pos_begin = parent.statements().position(|stmt| stmt == *begin).unwrap();
                let pos_end = parent.statements().position(|stmt| stmt == *end).unwrap();
                let parent = parent.clone_subtree();
                let begin = parent.statements().nth(pos_begin).unwrap();
                let end = parent.statements().nth(pos_end).unwrap();
                CodeRegion::Stmts { parent, elements: begin..=end }
            }
            CodeRegion::Decls(decls) => CodeRegion::Decls(decls.iter().map(|decl| decl.clone_subtree()).collect()),
        }
    }

    // LUB: Least Upper Bound, a single syntax node that contains all the elements in the region
    fn lub(&self) -> SyntaxNode {
        match self {
            CodeRegion::Expr(expr) => expr.syntax().clone(),
            CodeRegion::Stmts { parent, elements: _ } => {
                parent.syntax().clone()
            }
            CodeRegion::Decls(decls) => {
                get_source_file(&decls[0]).syntax().clone()
            }
        }
    }

    // Takes a TreeMutator or a SourceChangeBuilder and returns a mutable CodeRegion
    fn make_mut_with_mutator(&self, mutator: &TreeMutator) -> CodeRegion {
        match self {
            CodeRegion::Expr(expr) => CodeRegion::Expr(mutator.make_mut(expr)),
            CodeRegion::Stmts { parent, elements } => {
                let start_mut = mutator.make_mut(elements.start());
                let end_mut = mutator.make_mut(elements.end());
                CodeRegion::Stmts { parent: mutator.make_mut(parent), elements: start_mut..=end_mut }
            }
            CodeRegion::Decls(decls) => {
                let mut new_decls = Vec::new();
                for decl in decls {
                    new_decls.push(mutator.make_mut(decl));
                }
                CodeRegion::Decls(new_decls)
            }
        }
    }

    fn make_mut_with_builder(&self, builder: &mut SourceChangeBuilder) -> CodeRegion {
        match self {
            CodeRegion::Expr(expr) => CodeRegion::Expr(builder.make_mut(expr.clone())),
            CodeRegion::Stmts { parent, elements } => {
                let start_mut = builder.make_mut(elements.start().clone());
                let end_mut = builder.make_mut(elements.end().clone());
                CodeRegion::Stmts { parent: builder.make_mut(parent.clone()), elements: start_mut..=end_mut }
            }
            CodeRegion::Decls(decls) => {
                let mut new_decls = Vec::new();
                for decl in decls {
                    new_decls.push(builder.make_mut(decl.clone()));
                }
                CodeRegion::Decls(new_decls)
            }
        }
    }

    // Peels tag from expr or stmts, does nothing for decls
    // The CodeRegion must align with that generated from HayrollSeed::get_raw_code_region
    // Returns immutable CodeRegion that is no longer part of the original syntax tree
    fn peel_tag(&self) -> CodeRegion {
        let mutator = TreeMutator::new(&self.lub());
        let mut_region = match self {
            CodeRegion::Expr(expr) => {
                if let Some(if_expr) = ast::IfExpr::cast(expr.syntax().clone()) {
                    let then_branch = if_expr.then_branch().unwrap();
                    let then_branch_mut = mutator.make_mut(&then_branch);
                    CodeRegion::Expr(then_branch_mut.into())
                } else {
                    let star_expr = ast::PrefixExpr::cast(expr.syntax().clone()).unwrap();
                    let star_expr_mut = mutator.make_mut(&star_expr);
                    let mut if_or_paren_expr = star_expr.expr().unwrap();
                    while let Some(paren_expr) = ast::ParenExpr::cast(if_or_paren_expr.syntax().clone()) {
                        if_or_paren_expr = paren_expr.expr().unwrap();
                    }
                    let if_expr = ast::IfExpr::cast(if_or_paren_expr.syntax().clone()).unwrap();
                    let then_branch = if_expr.then_branch().unwrap();
                    let if_expr_mut = mutator.make_mut(&if_expr);
                    let then_branch_mut = mutator.make_mut(&then_branch);
                    ted::replace(if_expr_mut.syntax(), then_branch_mut.syntax());
                    CodeRegion::Expr(star_expr_mut.into())
                }
            }
            CodeRegion::Stmts { parent, elements } => {
                let stmt_begin = elements.start();
                let stmt_end = elements.end();
                let stmt_begin_next: ast::Stmt = ast::Stmt::cast(stmt_begin.syntax().next_sibling().unwrap()).unwrap();
                let stmt_end_prev: ast::Stmt = ast::Stmt::cast(stmt_end.syntax().prev_sibling().unwrap()).unwrap();
                let parent_mut = mutator.make_mut(parent);
                CodeRegion::Stmts {
                    parent: parent_mut,
                    elements: stmt_begin_next..=stmt_end_prev,
                }
            }
            CodeRegion::Decls(_) => {
                self.make_mut_with_mutator(&mutator) // Decls do not need special handling
            }
        };
        mut_region.clone_subtree()
    }

    // Give every decls item that is scoped in a `extern "C"` its own unique scope
    // Expr and stmts stay the same
    // Returns immutable CodeRegion that is no longer part of the original syntax tree
    fn individualize_decls(&self) -> CodeRegion {
        let mutator = TreeMutator::new(&self.lub());
        let mut_region = match self {
            CodeRegion::Expr(_) => {
                self.make_mut_with_mutator(&mutator)
            }
            CodeRegion::Stmts { parent: _, elements: _ } => {
                self.make_mut_with_mutator(&mutator)
            }
            CodeRegion::Decls(items) => {
                let items_processed: Vec<ast::Item> = items.into_iter().map(|item| {
                    if let Some(_) = parent_until_kind_and_cond::<ast::ExternBlock>(item, |ext| {
                        ext.abi().map_or(false, |abi| {
                            abi.abi_string().map_or(false, |s| s.value().unwrap() == "C")
                        })
                    }) {
                        // If the item is wrapped in extern "C", return it as-is
                        let new_extern_c_str = format!("extern \"C\" {{\n    {}\n}}", item.to_string());
                        let new_extern_c = expr_from_text(&new_extern_c_str);
                        let new_extern_c = mutator.make_mut(&new_extern_c);
                        ast::Item::cast(new_extern_c.syntax().clone()).unwrap()
                    } else {
                        mutator.make_mut(item)
                    }
                }).collect::<Vec<_>>();
                CodeRegion::Decls(items_processed)
            }
        };
        mut_region.clone_subtree()
    }

    // Returns a range of syntax elements that represent the code region.
    // This is to provide a unified way of iterating over the code region, whether it's a single expression or a span of statements.
    // NOTE: Only valid for Expr and Stmts variants; Decls is not well-defined for syntax element ranges.
    fn syntax_element_range(&self) -> RangeInclusive<SyntaxElement> {
        match self {
            CodeRegion::Expr(expr) => expr.syntax().syntax_element().clone()..=expr.syntax().syntax_element().clone(),
            CodeRegion::Stmts { parent: _, elements } => {
                let start = elements.start();
                let end = elements.end();
                start.syntax().syntax_element().clone()..=end.syntax().syntax_element().clone()
            }
            CodeRegion::Decls(_) => {
                panic!("syntax_element_range is not well-defined for Decls variant - use syntax_element_vec instead");
            }
        }
    }

    // Returns a vector of syntax elements that represent the code region.
    #[allow(dead_code)]
    fn syntax_element_vec(&self) -> Vec<SyntaxElement> {
        match self {
            CodeRegion::Expr(expr) => vec![expr.syntax().syntax_element().clone()],
            CodeRegion::Stmts { parent, elements } => {
                let start = elements.start();
                let end = elements.end();
                let mut seen_begin = false;
                let mut seen_end = false;
                parent.statements().filter_map(|stmt| {
                    let mut ret: Option<ast::Stmt> = None;
                    if &stmt == start {
                        seen_begin = true;
                        ret = Some(stmt.clone())
                    } 
                    if &stmt == end {
                        seen_end = true;
                        ret = Some(stmt.clone())
                    } 
                    if seen_begin && !seen_end {
                        ret = Some(stmt.clone())
                    }
                    ret
                }).map(|stmt| stmt.syntax().clone().into()).collect::<Vec<SyntaxElement>>()
            }
            CodeRegion::Decls(decls) => {
                decls.iter().map(|decl| decl.syntax().syntax_element().clone()).collect::<Vec<SyntaxElement>>()
            }
        }
    }
}

impl std::fmt::Display for CodeRegion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CodeRegion::Expr(expr) => write!(f, "{}", expr),
            CodeRegion::Stmts { parent, elements } => {
                let start = elements.start();
                let end = elements.end();
                write!(f, "{}", {
                    let mut seen_begin = false;
                    let mut seen_end = false;
                    parent.statements().filter_map(|stmt| {
                        let mut ret: Option<String> = None;
                        if &stmt == start {
                            seen_begin = true;
                            ret = Some(stmt.to_string())
                        } 
                        if &stmt == end {
                            seen_end = true;
                            ret = Some(stmt.to_string())
                        } 
                        if seen_begin && !seen_end {
                            ret = Some(stmt.to_string())
                        }
                        ret
                    }).collect::<Vec<String>>().join("\n")
                })
            }
            CodeRegion::Decls(decls) => {
                write!(f, "{}", decls.iter().map(|decl| decl.to_string()).collect::<Vec<String>>().join("\n"))
            }
        }
    }
}

// HayrollMacroInv is a macro invocation in AST representation
// It contains the CodeRegion of the expansion range and the CodeRegions of the arguments
#[derive(Clone)]
struct HayrollMacroInv {
    seed: HayrollSeed,
    // Args is a list of (argument name, list of HayrollSeed) pairs
    args: Vec<(String, Vec<HayrollSeed>)>,
}

impl HasHayrollTag for HayrollMacroInv {
    fn hayroll_tag(&self) -> &HayrollTag { self.seed.hayroll_tag() }
}

impl HayrollMacroInv {
    // Replace the args tagged code regions into $argName, for generating macro definition
    // Takes a lambda that inputs a &HayrollSeed (arg) then generates a vec::SyntaxElement to replace the code region
    // Returns immutable CodeRegion
    fn replace_arg_regions_into(
        &self,
        peel_tag: bool,
        return_inv_region_with_deref: bool,
        replace_arg_region_with_deref: bool,
        substitute: fn(&HayrollSeed) -> Vec<SyntaxElement>
    ) -> CodeRegion {
        let mut delayed_tasks: Vec<Box<dyn FnOnce()>> = Vec::new();
        let region = self.seed.get_raw_code_region(
            return_inv_region_with_deref
        );
        let mutator = TreeMutator::new(&region.lub());
        let region_mut = region.make_mut_with_mutator(&mutator);
        for (_, arg_regions) in self.args.iter() {
            for arg_region in arg_regions {
                let arg_code_region = arg_region.get_raw_code_region(
                    replace_arg_region_with_deref
                );
                let arg_code_region_mut = arg_code_region.make_mut_with_mutator(&mutator);
                // It's safe to call syntax_element_range() because decls is not allowed as an arg
                let arg_code_region_range = arg_code_region_mut.syntax_element_range();
                let new_tokens = substitute(arg_region);
                delayed_tasks.push(Box::new(move || {
                    ted::replace_all(arg_code_region_range, new_tokens);
                }));
            }
        }
        for task in delayed_tasks {
            task();
        }
        let region_immut = region_mut.clone_subtree();
        if peel_tag {
            region_immut.peel_tag()
        } else {
            region_immut
        }
    }

    // Returns mutable ast::MacroRules node
    fn macro_rules(&self) -> ast::MacroRules {
        let macro_name = self.name();
        // arg format: ($x:expr) or ($x:stmt)
        let macro_args = self.args.iter()
            .map(|(arg_name, arg_regions)| {
                let arg_type = match arg_regions[0] {
                    HayrollSeed::Expr(_) => "expr",
                    HayrollSeed::Stmts(_, _) => "stmt",
                    HayrollSeed::Decls(_) => panic!("Decls not supported as macro arg"),
                };
                format!("${}:{}", arg_name, arg_type)
            })
            .collect::<Vec<String>>()
            .join(", ");
        let macro_body = match self.seed {
            HayrollSeed::Expr(_) | HayrollSeed::Stmts(_, _) => {
                self.replace_arg_regions_into(
                    true,
                    true,
                    true, 
                    |arg_region| {
                        let name = arg_region.name();
                        let name_token = ast::make::tokens::ident(&name);
                        let name_node = name_token.parent().unwrap().clone_for_update();
                        let dollar_token_mut = get_dollar_token_mut();
                        vec![syntax::NodeOrToken::Token(dollar_token_mut), syntax::NodeOrToken::Node(name_node)]
                    }
                )
            }
            HayrollSeed::Decls(_) => {
                self.seed.get_raw_code_region(true).individualize_decls()
            }
        };
        let macro_def = format!("macro_rules! {}\n{{\n    ({}) => {{\n    {}\n    }}\n}}", macro_name, macro_args, macro_body);
        // Convert the macro definition into a syntax node
        let macro_rules_node = ast_from_text::<ast::MacroRules>(&macro_def);
        let macro_rules_node = macro_rules_node.clone_for_update();
        macro_rules_node
    }

    // Returns mutable node
    fn macro_call(&self) -> ast::MacroCall {
        let macro_name = self.name();
        let args_spelling: String = self.args.iter()
            .map(|(_, arg_regions)| {
                let arg_code_region = arg_regions[0].get_raw_code_region(
                    true // pass lvalue to macro actual args
                ).peel_tag();
                arg_code_region.to_string()
            })
            .collect::<Vec<String>>()
            .join(", ");        
        let macro_call = if self.is_expr() {
            format!("{}!({})", macro_name, args_spelling)
        } else {
            format!("{}!({});", macro_name, args_spelling)
        };
        ast_from_text::<ast::MacroCall>(&macro_call).clone_for_update()
    }

    fn fn_(&self) -> ast::Fn {
        let return_type: String = match self.seed.lrvalue_type() {
            Some(t) => " -> ".to_string() + &t.to_string(),
            None => "".to_string(),
        };
        let arg_with_types = self.args.iter()
            .filter_map(|(arg_name, arg_regions)| {
                if arg_regions.is_empty() {
                    // Ignore args that are never used, but print a warning
                    eprintln!("Warning: in macro {} argument {} is never used", self.name(), arg_name);
                    None
                } else {
                    let t = arg_regions[0].lrvalue_type().unwrap();
                    Some(format!("{}: {}", arg_name, t))
                }
            })
            .collect::<Vec<String>>()
            .join(", ");
        let fn_body = self.replace_arg_regions_into(
            true,
            false,
            false,
            |arg_region| {
                let name = arg_region.name();
                let name_token = ast::make::tokens::ident(&name);
                let name_node = name_token.parent().unwrap().clone_for_update();
                vec![syntax::NodeOrToken::Node(name_node)]
            }
        );
        let fn_ = format!("unsafe fn {}({}){} {{\n    {}\n}}", self.seed.name(), arg_with_types, return_type, fn_body);
        ast_from_text::<ast::Fn>(&fn_).clone_for_update()
    }

    // Returns mutable node
    fn call_expr(&self) -> ast::Expr {
        // lvalue: *if{}else{} -> *NAME(*mut (lvalue_spelling), rvalue_spelling)
        // rvalue: if{}else{} -> NAME(*mut (lvalue_spelling), rvalue_spelling)
        // stmt: *"";{};*""; -> NAME(*mut (lvalue_spelling), rvalue_spelling); // WE ARE NOT HANDLING IT SEMICOLON HERE
        let fn_name = self.name();
        let args_spelling: String = self.args.iter()
            .filter_map(|(_, arg_regions)| {
                if arg_regions.is_empty() {
                    // Ignore args that are never used, but print a warning
                    eprintln!("Warning: in macro {} an argument is never used", self.name());
                    None
                } else {
                    let arg_code_region = arg_regions[0].get_raw_code_region(
                        false, // pass rvalue to fn actual args
                    ).peel_tag();
                    Some(arg_code_region.to_string())
                }
            })
            .collect::<Vec<String>>()
            .join(", ");
        let call_expr = format!("{}({})", fn_name, args_spelling);
        let call_expr = if self.is_lvalue() {
            format!("*{}", call_expr)
        } else {
            call_expr
        };
        expr_from_text(&call_expr).clone_for_update()
    }

    // Returns mutable node
    fn call_expr_or_stmt_mut(&self) -> SyntaxNode {
        let call_expr = self.call_expr();
        if self.seed.is_expr() {
            call_expr.syntax().clone()
        } else {
            let stmt = ast::make::expr_stmt(call_expr).clone_for_update();
            stmt.syntax().clone()
        }
    }

    fn args_internally_structurally_compatible(&self) -> bool {
        // For an argument that is used more than once,
        // check that all of its uses have the same ASTKind
        self.args.iter().all(|(_, seeds)| {
            seeds.is_empty()
            || seeds.iter().all(|seed| seed.is_structurally_compatible_with(&seeds[0]))
        })
    }

    fn args_internally_type_compatible(&self) -> bool {
        // For an argument that is used more than once,
        // check that all of its uses have the same ASTKind,
        // and for Expr, also have the same type
        self.args.iter().all(|(_, seeds)| {
            seeds.is_empty()
            || seeds.iter().all(|seed| seed.is_type_compatible_with(&seeds[0]))
        })
    }

    fn is_structurally_compatible_with(&self, other: &Self) -> bool {
        self.seed.is_structurally_compatible_with(&other.seed)
        && self.args_internally_structurally_compatible() && other.args_internally_structurally_compatible()
        && self.args.len() == other.args.len()
        && self.args.iter().zip(other.args.iter()).all(|((_, seeds1), (_, seeds2))| {
            if seeds1.is_empty() && seeds2.is_empty() {
                true
            } else if seeds1.is_empty() != seeds2.is_empty() {
                false
            } else {
                seeds1[0].is_structurally_compatible_with(&seeds2[0])
            }
        })
    }

    fn is_type_compatible_with(&self, other: &Self) -> bool {
        self.seed.is_type_compatible_with(&other.seed)
        && self.args_internally_type_compatible() && other.args_internally_type_compatible()
        && self.args.len() == other.args.len()
        && self.args.iter().zip(other.args.iter()).all(|((_, seeds1), (_, seeds2))| {
            if seeds1.is_empty() && seeds2.is_empty() {
                true
            } else if seeds1.is_empty() != seeds2.is_empty() {
                false
            } else {
                seeds1[0].is_type_compatible_with(&seeds2[0])
            }
        })
    }
}

struct HayrollMacroCluster {
    invocations: Vec<HayrollMacroInv>,
}

impl HasHayrollTag for HayrollMacroCluster {
    fn hayroll_tag(&self) -> &HayrollTag { self.invocations[0].hayroll_tag() }
}

impl HayrollMacroCluster {
    fn can_be_fn(&self) -> bool {
        self.invs_internally_type_compatible()
        && self.invocations.iter().all(|inv| inv.can_be_fn())
    }

    fn invs_internally_structurally_compatible(&self) -> bool {
        assert!(!self.invocations.is_empty());
        let first = &self.invocations[0];
        self.invocations.iter().all(|inv| {
            inv.is_structurally_compatible_with(&first)
        })
    }

    fn invs_internally_type_compatible(&self) -> bool {
        assert!(!self.invocations.is_empty());
        let first = &self.invocations[0];
        self.invocations.iter().all(|inv| {
            inv.is_type_compatible_with(&first)
        })
    }

    fn macro_rules(&self) -> ast::MacroRules {
        assert!(self.invs_internally_structurally_compatible());
        self.invocations[0].macro_rules()
    }

    fn macro_call(&self) -> ast::MacroCall {
        assert!(self.invs_internally_structurally_compatible());
        self.invocations[0].macro_call()
    }

    fn fn_(&self) -> ast::Fn {
        assert!(self.invs_internally_type_compatible());
        self.invocations[0].fn_()
    }

    fn call_expr(&self) -> ast::Expr {
        assert!(self.invs_internally_type_compatible());
        self.invocations[0].call_expr()
    }

    fn call_expr_or_stmt_mut(&self) -> SyntaxNode {
        assert!(self.invs_internally_type_compatible());
        self.invocations[0].call_expr_or_stmt_mut()
    }

}

// HayrollMacroDB is a database of HayrollMacroInv collected from the source code
struct HayrollMacroDB{
    map: HashMap<String, HayrollMacroCluster>, // definition location -> invocations
}

impl HayrollMacroDB {
    fn new() -> Self {
        HayrollMacroDB {
            map: HashMap::new(),
        }
    }

    fn from_hayroll_macro_invs(hayroll_macros: &Vec<HayrollMacroInv>) -> Self {
        // Collect macros by locDecl
        let mut db = HayrollMacroDB::new();
        for mac in hayroll_macros.iter() {
            let loc_decl = mac.loc_begin();
            if !db.map.contains_key(&loc_decl) {
                db.map.insert(loc_decl.clone(), HayrollMacroCluster { invocations: Vec::new() });
            }
            db.map.get_mut(&loc_decl).unwrap().invocations.push(mac.clone());
        }
        db
    }
}

fn main() -> Result<()> {
    // Record the start time
    let start = Instant::now();

    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <workspace-path>", args[0]);
        std::process::exit(1);
    }

    let workspace_path = Path::new(&args[1]);
    let cargo_config = CargoConfig::default();
    let load_cargo_config = load_cargo::LoadCargoConfig {
        load_out_dirs_from_check: false,
        with_proc_macro_server: load_cargo::ProcMacroServerChoice::None,
        prefill_caches: false,
    };

    // Print consumed time, tag "load_cargo"
    let duration = start.elapsed();
    println!("Time elapsed in load_cargo is: {:?}", duration);

    let (mut db, vfs, _proc_macro) = load_cargo::load_workspace_at(workspace_path, &cargo_config, &load_cargo_config, &|_| {})?;
    
    // Print consumed time, tag "db"
    let duration = start.elapsed();
    println!("Time elapsed in db is: {:?}", duration);

    // let sema = &hir::Semantics::new(&db);
    // // Print consumed time, tag "sema"
    // let duration = start.elapsed();
    // println!("Time elapsed in sema is: {:?}", duration);

    let mut syntax_roots: HashMap<FileId, (SourceFile, Option<SourceChangeBuilder>)> = db.local_roots().iter()
        .flat_map(|&srid| db.source_root(srid).iter().collect::<Vec<_>>())
        .filter_map(|file_id| {
            // Include only Rust source files, not toml files
            if !vfs.file_path(file_id).to_string().ends_with(".rs") {
                return None;
            }
            let builder = SourceChangeBuilder::new(file_id.clone());
            // Using the sema-based parser allows querying semantic info i.e. type of an expression
            // But it's much slower than the db-based parser
            // let root = sema.parse_guess_edition(file_id);
            let root = db.parse(EditionedFileId::current_edition(file_id)).tree();
            Some((file_id, (root, Some(builder))))
        })
        .collect();

    // Print consumed time, tag "syntax_roots"
    let duration = start.elapsed();
    println!("Time elapsed in syntax_roots is: {:?}", duration);

    println!("Found {} Rust files in the workspace", syntax_roots.len());
    // Print all filenames in the workspace
    for (file_id, (_root, _)) in &syntax_roots {
        println!("File: {}", vfs.file_path(*file_id));
    }

    let hayroll_tags: Vec<HayrollTag> = syntax_roots
        .iter()
        .flat_map(|(file_id, (root, _))| {
            root.syntax().descendants_with_tokens()
            // Attatch a file_id to each node
            .map(move |element| (element, file_id))
        })
        .filter_map(|(element, file_id)| {
            if let Some(token) = element.clone().into_token() {
                if let Some(byte_str) = ast::ByteString::cast(token) {
                    // Try to parse into serde_json::Value, if it fails, it's not a JSON string
                    let content = match byte_str.value() {
                        Ok(cow) => String::from_utf8_lossy(&cow).to_string(),
                        Err(_) => return None,
                    };
                    // Delete the last \0 byte
                    let content = content.trim_end_matches(char::from(0));
                    let tag: serde_json::Result<value::Value> = serde_json::from_str(&content);
                    println!("Byte String: {}, Tag: {:?}", content, tag);
                    if let Ok(tag) = tag {
                        if tag["hayroll"] == true {
                            return Some(HayrollTag {
                                literal: ast::Literal::cast(element.parent()?)?,
                                tag,
                                file_id: file_id.clone(),
                            });
                        }
                    }
                }
            }
            None
        })
        .collect();

    // Pair up stmt hayroll_literals that are in the same scope and share the locInv in info
    let hayroll_seeds : Vec<HayrollSeed> = hayroll_tags.iter()
        .fold(Vec::new(), |mut acc, tag| {
            if tag.is_expr() {
                assert!(tag.begin());
                acc.push(HayrollSeed::Expr(tag.clone()));
            } else if (tag.is_stmt() || tag.is_stmts()) && tag.begin() == true {
                acc.push(HayrollSeed::Stmts(tag.clone(), tag.clone())); // For now seedBegin == seedEnd
            } else if tag.is_decl() || tag.is_decls() {
                assert!(tag.begin());
                acc.push(HayrollSeed::Decls(tag.clone()));
            } else if !tag.begin() {
                // Search through the acc to find the begin stmt with the same locInv
                let mut found = false;
                for seed in acc.iter_mut().rev() {
                    match seed {
                        HayrollSeed::Stmts(tag_begin, tag_end) => {
                            if tag_begin.loc_begin() == tag.loc_begin() {
                                *tag_end = tag.clone();
                                found = true;
                                break;
                            }
                        }
                        _ => {}
                    }
                }
                // Assert found
                if !found {
                    panic!("No matching begin stmt found for end stmt");
                }
            } else {
                panic!("Unknown tag");
            }
            acc
        }
    );

    // A region whose isArg is false is a macro
    // Other regions are arguments, we should match them with the macro
    let hayroll_macro_invs: Vec<HayrollMacroInv> = hayroll_seeds.iter()
        .fold(Vec::new(), |mut acc, region| {
            if region.is_arg() == false {
                // Pre-populate all expected argument names with empty vectors
                let preset_args: Vec<(String, Vec<HayrollSeed>)> = region.arg_names()
                    .into_iter()
                    .map(|name| (name, Vec::new()))
                    .collect();
                acc.push(HayrollMacroInv {
                    seed: region.clone(),
                    args: preset_args,
                });
            } else {
                let mut found = false;
                for mac in acc.iter_mut().rev() {
                    if mac.loc_begin() == region.loc_ref_begin() {
                        assert!(mac.args.iter().any(|(name, _)| name == &region.name()));
                        // The arg must already exist, push the region to the existing arg
                        let arg = mac.args.iter_mut().find(|(name, _)| name == &region.name()).unwrap();
                        arg.1.push(region.clone());
                        found = true;
                        break;
                    }
                }
                // Assert found
                if !found {
                    panic!("No matching macro found for arg: {:?}", region.loc_begin());
                }
            }
            acc
        });

    let hayroll_macro_db = HayrollMacroDB::from_hayroll_macro_invs(&hayroll_macro_invs);

    // Print consumed time, tag "hayroll_literals"
    let duration = start.elapsed();
    println!("Time elapsed in hayroll_literals is: {:?}", duration);
        
    // Find out all Expr typed nodes, and replace them with their nested value
    // if (*"str") { A } else { B } -> A
    // *if (*"str") { &A } else { B } -> *&A

    let mut delayed_tasks: Vec<Box<dyn FnOnce()>> = Vec::new();

    // For each macro db entry, generate a new macro/func definition and add that to the top/bottom of the file
    // For each macro invocation, replace the invocation with a macro/func call
    for (_loc_decl, cluster) in hayroll_macro_db.map.iter() {
        // There is at least one macro invocation for each locDecl
        let (syntax_root, builder) = syntax_roots.get_mut(&cluster.file_id()).unwrap();
        let builder = builder.as_mut().unwrap();
        let syntax_root_mut = builder.make_mut(syntax_root.clone());

        if cluster.can_be_fn() {
            // Add the function definition to the bottom of the file
            let fn_ = cluster.fn_();
            let fn_elem = fn_.syntax().syntax_element().clone();
            delayed_tasks.push(Box::new(move || {
                ted::insert_all(bot_pos(&syntax_root_mut), vec![get_empty_line_element_mut(), fn_elem]);
            }));

            // Replace the macro expansions with the function calls
            for inv in cluster.invocations.iter() {
                let code_region = inv.seed.get_raw_code_region(
                    false // A C function always returns an rvalue
                );
                let (_, builder) = syntax_roots.get_mut(&inv.file_id()).unwrap();
                let builder = builder.as_mut().unwrap();
                let region_mut = code_region.make_mut_with_builder(builder);
                let region_mut_element_range = region_mut.syntax_element_range();
                let fn_call_node = cluster.call_expr_or_stmt_mut().syntax_element();
                // We can call syntax_element_range() here because decls macro cannot be wrapped into a function
                delayed_tasks.push(Box::new(move || {
                    ted::replace_all(region_mut_element_range, vec![fn_call_node]);
                }));
            }
        } else if cluster.invs_internally_structurally_compatible() {
            let macro_rules = cluster.macro_rules();
            let macro_rules_elem = macro_rules.syntax().syntax_element();
            let top = top_pos(&syntax_root_mut);
            delayed_tasks.push(Box::new(move || {
                ted::insert_all(top, vec![macro_rules_elem, get_empty_line_element_mut()])
            }));

            // Replace the macro invocations with the macro calls
            for inv in cluster.invocations.iter() {
                let code_region = inv.seed.get_raw_code_region(
                    true // A macro invocation can be an lvalue or rvalue, so we pass true
                );
                let (_, builder) = syntax_roots.get_mut(&inv.file_id()).unwrap();
                let builder = builder.as_mut().unwrap();
                let region_mut = code_region.make_mut_with_builder(builder);
                let macro_call_node = cluster.macro_call().syntax().syntax_element();

                match code_region {
                    CodeRegion::Expr(_) | CodeRegion::Stmts { .. } => {
                        // Replace the macro invocation with the macro call
                        let region_mut_element_range = region_mut.syntax_element_range();
                        delayed_tasks.push(Box::new(move || {
                            ted::replace_all(region_mut_element_range, vec![macro_call_node]);
                        }));
                    }
                    CodeRegion::Decls(_) => {
                        // Remove all original items, plus the seed item itself
                        // Then insert the macro call to the end of the file
                        let mut items = region_mut.syntax_element_vec();
                        let seed_item = inv.seed.get_raw_decls_tag_item();
                        let seed_item_mut = builder.make_mut(seed_item);
                        items.push(seed_item_mut.syntax().syntax_element().clone());
                        let bot = bot_pos(&syntax_root_mut);
                        // print all items to be removed
                        print!("Removing items: ");
                        for item in &items {
                            print!("{:?}, ", item);
                        }
                        delayed_tasks.push(Box::new(move || {
                            ted::remove_all_iter(items);
                            ted::insert_all(bot, vec![get_empty_line_element_mut(), macro_call_node]);
                        }));
                    }
                }
            }
        } else {
            eprintln!("Warning: Hayroll macro at {} cannot be converted to function or macro_rules! due to incompatible argument usage. Skipping.", cluster.invocations[0].loc_begin());
        }
    }

    // Print consumed time, tag "replace"
    let duration = start.elapsed();
    println!("Time elapsed in replace is: {:?}", duration);

    for task in delayed_tasks {
        task();
    }


    // Print consumed time, tag "analysis"
    let duration = start.elapsed();
    println!("Time elapsed in analysis is: {:?}", duration);

    let mut source_change = SourceChange::default();
    for (_, (_, builder)) in syntax_roots.iter_mut() {
        let builder = builder.take().unwrap();
        source_change = source_change.merge(builder.finish());
    }

    apply_source_change(&mut db, &source_change);

    for file_id in syntax_roots.keys() {
        let file_path = vfs.file_path(*file_id);
        let code = db.file_text(*file_id).to_string();
        // Attatch a new line at the end of the file, if it doesn't exist
        let code = if code.ends_with("\n") {
            code
        } else {
            code + "\n"
        };
        let path = file_path.as_path().unwrap();
        fs::write(path, code)?;
    }

    // Print consumed time, tag "write"
    let duration = start.elapsed();
    println!("Time elapsed in write is: {:?}", duration);

    Ok(())
}

// Apply the source change to the RootDatabase
fn apply_source_change(db: &mut RootDatabase, source_change: &ide::SourceChange){
    // Fs edits (NOT TESTED!!!)
    // for file_system_edit in source_change.file_system_edits.iter() {
    //     let (dst, contents) = match file_system_edit {
    //         ide::FileSystemEdit::CreateFile { dst, initial_contents } => (dst, initial_contents.clone()),
    //         ide::FileSystemEdit::MoveFile { src, dst } => {
    //             (dst, db.file_text(*src).to_string())
    //         }
    //         ide::FileSystemEdit::MoveDir { src, src_id, dst } => {
    //             // temporary placeholder for MoveDir since we are not using MoveDir in ide assists yet.
    //             (dst, format!("{src_id:?}\n{src:?}"))
    //         }
    //     };
    //     let sr = db.file_source_root(dst.anchor);
    //     let sr = db.source_root(sr);
    //     let mut base = sr.path_for_file(&dst.anchor).unwrap().clone();
    //     base.pop();
    //     let created_file_path = base.join(&dst.path).unwrap();
    //     fs::write(created_file_path.as_path().unwrap(), contents).unwrap();
    // }

    // Source file edits
    for (file_id, (text_edit, snippet)) in source_change.source_file_edits.iter() {
        let mut code = db.file_text(file_id.clone()).to_string();
        text_edit.apply(&mut code);
        // Snippet (NOT TESTED!!!)
        if let Some(snippet) = snippet {
            snippet.apply(&mut code);
        }
        db.set_file_text(*file_id, &code);
    }
}
